# MEMORIA DEL PROYECTO
/////////////////////////////////////
#PASSWORD APLICATION AUDITIVO:  
YcYX xq7G EvCI egVF qVZ3 1xZ6

WordPress genera y valida las contraseñas de aplicación con los espacios incluidos. No elimines los espacios ni los reemplaces por otros caracteres.
///////////////////////////

## Estructura del Proyecto
El proyecto está organizado en tres carpetas principales:
- `client`: Contiene la aplicación frontend desarrollada con Next.js
- `server`: Contiene la API backend desarrollada con Node.js y Express
- `memoria`: Contiene este documento de memoria del proyecto

## Layout del Proyecto

### Frontend (client)
La estructura del frontend sigue el patrón de organización de Next.js:
- `public/`: Archivos estáticos como imágenes y SVGs
- `src/app/`: Componentes y páginas de la aplicación
  - `layout.tsx`: Define la estructura común para todas las páginas
  - `page.tsx`: Página principal de la aplicación
- Archivos de configuración: next.config.ts, tsconfig.json, etc.

### Backend (server)
La estructura del backend sigue una organización modular:
- `index.js`: Punto de entrada de la aplicación con rutas y configuración del servidor
- `config/`: Archivos de configuración
  - `db.js`: Configuración de la conexión a la base de datos MySQL
- `models/`: Modelos de datos y lógica de negocio
  - `db.init.js`: Script para inicializar las tablas de la base de datos
  - `usuario.model.js`: Modelo para operaciones CRUD de usuarios
  - `blog.model.js`: Modelo para operaciones CRUD de blogs

## Base de Datos

### Diseño de la Base de Datos
Se ha implementado una base de datos relacional en MySQL con las siguientes tablas:

1. **Tabla de Usuarios (`usuarios`)**:
   - `id`: Identificador único de cada usuario.
   - `nombre`: Nombre del usuario.
   - `email`: Correo electrónico único del usuario.
   - `contraseña`: Contraseña almacenada de forma segura mediante hash.
   - `estilo_escritura`: Preferencia de estilo de escritura del usuario.
   - `fecha_creacion` y `fecha_actualizacion`: Tiempos de creación y última actualización del registro.

2. **Tabla de Blogs (`blogs`)**:
   - `id`: Identificador único de cada blog.
   - `nombre`: Nombre del blog.
   - `api_url`: URL de la API asociada al blog.
   - `favicon`: URL del favicon del blog.
   - `palabras_clave`: Palabras clave asociadas al blog.
   - `tematica`: Temática del blog.
   - `usuario_id`: Identificador del usuario propietario del blog.
   - `fecha_creacion` y `fecha_actualizacion`: Tiempos de creación y última actualización del registro.

### Relaciones
- Un usuario puede tener múltiples blogs (relación uno a muchos).
- Cada blog pertenece a un único usuario.

### Implementación de la Base de Datos

#### Función del Código
- **Conexión a la Base de Datos**: Configura un pool de conexiones para interactuar con MySQL de manera eficiente.
- **Inicialización de Tablas**: Crea las tablas `usuarios` y `blogs` si no existen, asegurando la integridad referencial mediante claves foráneas.
- **Operaciones CRUD**: Proporciona métodos para crear, leer, actualizar y eliminar registros en ambas tablas.

#### Librerías y Tecnologías Utilizadas
- **mysql2**: Para la conexión y operaciones con la base de datos MySQL. Se eligió por su soporte para promesas y su eficiencia en la gestión de conexiones.
- **dotenv**: Para gestionar variables de entorno, lo que permite mantener seguras las credenciales de la base de datos.
- **bcryptjs**: Para encriptar contraseñas, garantizando la seguridad de los datos sensibles de los usuarios.

#### Justificación de las Tecnologías
- **MySQL**: Base de datos relacional ampliamente utilizada, ideal para manejar relaciones entre tablas como usuarios y blogs.
- **mysql2**: Ofrece un rendimiento mejorado y soporte para promesas, lo que facilita la escritura de código asincrónico.
- **dotenv**: Simplifica la configuración del entorno, permitiendo cambiar credenciales sin modificar el código fuente.
- **bcryptjs**: Proporciona un método seguro para almacenar contraseñas, protegiendo contra ataques de fuerza bruta.

### Archivo de Configuración
Se creó un archivo de variables de entorno (`.env`) para almacenar las credenciales de la base de datos de forma segura:
```
DB_HOST=localhost
DB_USER=root
DB_PASSWORD=****
DB_NAME=blog_app
DB_PORT=3306
```

### Inicialización de la Base de Datos
El script de inicialización (`db.init.js`) crea automáticamente la base de datos y las tablas si no existen, con las siguientes características:
- Creación de tablas con restricciones de integridad referencial
- Campos para fechas de creación y actualización automáticas
- Claves foráneas con eliminación en cascada para mantener la integridad de los datos

### API RESTful

#### Función del Código
- **Gestión de Usuarios**: Permite registrar, listar, actualizar y eliminar usuarios.
- **Gestión de Blogs**: Permite registrar, listar, actualizar y eliminar blogs, además de asociarlos a usuarios específicos.

#### Endpoints Implementados
- **Usuarios**:
  - `POST /api/usuarios`: Crear un nuevo usuario.
  - `GET /api/usuarios`: Listar todos los usuarios.
  - `GET /api/usuarios/:id`: Obtener un usuario específico por ID.
  - `PUT /api/usuarios/:id`: Actualizar un usuario existente.
  - `DELETE /api/usuarios/:id`: Eliminar un usuario.
- **Blogs**:
  - `POST /api/blogs`: Crear un nuevo blog.
  - `GET /api/blogs`: Listar todos los blogs.
  - `GET /api/blogs/:id`: Obtener un blog específico por ID.
  - `GET /api/usuarios/:id/blogs`: Obtener todos los blogs de un usuario específico.
  - `PUT /api/blogs/:id`: Actualizar un blog existente.
  - `DELETE /api/blogs/:id`: Eliminar un blog.

#### Librerías y Tecnologías Utilizadas
- **Express**: Framework para construir la API REST de manera rápida y modular.
- **mysql2**: Para interactuar con la base de datos desde los endpoints.
- **bcryptjs**: Para validar contraseñas durante el inicio de sesión.

#### Justificación de las Tecnologías
- **Express**: Su simplicidad y flexibilidad lo hacen ideal para construir APIs RESTful.
- **mysql2**: Permite realizar consultas eficientes y seguras a la base de datos.
- **bcryptjs**: Garantiza la seguridad de las contraseñas durante el proceso de autenticación.

## Implementación de Integración con WordPress

### Gestión de Blogs

#### Mejoras en la Base de Datos
Se ha ampliado la tabla de blogs para incluir el campo `api_key` que almacena la contraseña de aplicación de WordPress necesaria para la autenticación con la API. La estructura actualizada de la tabla es:

- `id`: Identificador único del blog
- `nombre`: Nombre descriptivo del blog
- `api_url`: URL del sitio WordPress
- `api_key`: Contraseña de aplicación para autenticarse con la API de WordPress
- `favicon`: URL del favicon del sitio, extraído automáticamente
- `palabras_clave`: Palabras clave asociadas al blog
- `tematica`: Temática principal del blog
- `usuario_id`: Identificador del usuario propietario
- Campos de timestamp para controlar la creación y actualización

#### Extracción Automática de Favicons
Se ha implementado una funcionalidad para extraer automáticamente el favicon de un sitio web WordPress. El proceso sigue estos pasos:

1. El sistema analiza el HTML de la página utilizando Cheerio
2. Busca en diferentes elementos `link` con atributos como `rel="icon"`, `rel="shortcut icon"`, etc.
3. Si encuentra un favicon, resuelve la URL completa
4. Si no encuentra un favicon específico, utiliza la ruta por defecto `/favicon.ico`
5. Como fallback, utiliza el servicio de Google para favicons

#### Librerías y Tecnologías Utilizadas
- **Cheerio**: Para analizar y extraer información del HTML de los sitios web WordPress.
- **Axios**: Para realizar peticiones HTTP a la API de WordPress y obtener el HTML de los sitios.
- **Multer**: Para gestionar la subida de archivos como imágenes destacadas.

#### Funcionalidades Implementadas en el Cliente

##### Servicios
- **blogService.ts**: Servicio para gestionar operaciones CRUD de blogs y extracción de favicons.
- **wordpressService.ts**: Servicio para la comunicación con la API de WordPress.

##### Hooks Personalizados
- **useBlogManagement.ts**: Hook para gestionar la creación, listado y eliminación de blogs.
- **useWordPressForm.ts**: Hook para gestionar el formulario de publicación en WordPress.

##### Componentes
- **AddBlogModal.tsx**: Modal para añadir nuevos blogs con campos para nombre, URL, contraseña de aplicación y temática.

#### Interfaz de Usuario
- Se ha modificado el sidebar izquierdo para mostrar los blogs del usuario con sus favicons
- Se ha añadido un botón para crear nuevos blogs
- Se implementó un modal con formulario para la creación de blogs
- Los blogs creados se muestran en una lista con opciones para eliminar

#### API RESTful Extendida
Se han agregado nuevos endpoints en el servidor:

- `POST /api/utils/extract-favicon`: Extrae el favicon de una URL proporcionada
- `POST /api/wordpress/post/:blogId`: Publica una entrada en WordPress utilizando la API REST

### Justificación de las Tecnologías

#### Cheerio
Se eligió Cheerio para el análisis de HTML por su eficiencia y facilidad de uso. Es una implementación ligera de jQuery para servidores que permite navegar por documentos HTML con selectores familiares.

#### Separación de Responsabilidades
La arquitectura del proyecto se ha diseñado siguiendo el patrón de separación de responsabilidades:
- **Servicios**: Encapsulación de la lógica de comunicación con APIs
- **Hooks**: Gestión del estado y lógica de negocio
- **Componentes**: Presentación visual e interacción con el usuario

Esta separación facilita el mantenimiento, las pruebas y la escalabilidad del proyecto.

#### Gestión de Estado
Se utilizan hooks de React (useState, useEffect) para gestionar el estado de la aplicación de manera eficiente y modular, permitiendo compartir lógica entre componentes sin duplicar código.

---

[29/04/2025]
- Se añadió el campo 'wp_user' (usuario de WordPress) en el formulario de creación de blogs (AddBlogModal.tsx), en el estado del hook useBlogManagement.ts, en la interfaz Blog de blogService.ts y en la base de datos (db.init.js, blog.model.js).
- Se actualizó la lógica de creación de blogs para guardar también el usuario de WordPress junto a la contraseña de aplicación.
- Se modificó el backend (wordpress.controller.js) para que al publicar en WordPress utilice autenticación básica (Authorization: Basic base64(wp_user:api_key)) en vez de Bearer, usando los datos almacenados en la base de datos.
- Se añadió la migración automática de la columna 'wp_user' en la tabla blogs si no existe.
- Ahora la publicación de entradas en WordPress requiere tanto el usuario como la contraseña de aplicación, ambos configurables al crear el blog.

---

[09/05/2025]
# Migración a Vercel y Adaptación a Arquitectura Serverless

## Motivación de la Migración

La decisión de migrar el proyecto a Vercel responde a varios objetivos estratégicos:

1. **Simplificación de la infraestructura**: Unificar el frontend y backend en una única plataforma de despliegue.
2. **Escalabilidad mejorada**: Aprovechar la arquitectura serverless para escalar automáticamente según la demanda.
3. **Optimización de costes**: Reducir gastos de infraestructura al pagar solo por el tiempo de ejecución real.
4. **Mejora del rendimiento global**: Beneficiarse de la red de distribución de contenido (CDN) de Vercel.
5. **Integración continua**: Facilitar la implementación de un flujo de trabajo CI/CD directamente desde el repositorio de GitHub.

## Migración de la Base de Datos a Neon

### Selección de Neon como Proveedor de Base de Datos

La migración de nuestra base de datos MySQL local a Neon PostgreSQL se realizó por las siguientes razones:

- **Compatibilidad con arquitectura serverless**: Neon ofrece un servicio de base de datos PostgreSQL diseñado específicamente para entornos serverless, con escalado automático y facturación por uso.
- **Separación del almacenamiento y computación**: Permite optimizar costos al escalar estos recursos de manera independiente.
- **Alta disponibilidad**: Proporciona replicación automática y respaldos continuos.
- **API moderna**: Facilita la integración con aplicaciones serverless modernas.

### Proceso de Migración de la Base de Datos

El proceso de migración de datos de MySQL local a Neon PostgreSQL incluyó los siguientes pasos:

1. **Creación de la cuenta en Neon**: Se estableció un nuevo proyecto en la plataforma de Neon.
2. **Diseño del esquema en PostgreSQL**: Se adaptó el esquema existente de MySQL para aprovechar las características de PostgreSQL.
3. **Exportación de datos**: Se exportaron los datos de las tablas locales de MySQL.
4. **Transformación de datos**: Se ajustó el formato de los datos exportados para que fueran compatibles con PostgreSQL.
5. **Importación a Neon**: Se cargaron los datos transformados en la nueva base de datos.
6. **Verificación de integridad**: Se realizaron pruebas para asegurar que todos los datos se hubieran migrado correctamente.
7. **Actualización de credenciales**: Se actualizaron las variables de entorno en Vercel para incluir las nuevas credenciales de conexión.

### Adaptación del Código para PostgreSQL

La migración requirió cambios significativos en el código del proyecto:

- Reemplazo de la biblioteca `mysql2` por `pg` para conectarse a PostgreSQL.
- Adaptación de las consultas SQL para cumplir con la sintaxis de PostgreSQL.
- Modificación de los tipos de datos para aprovechar los tipos nativos de PostgreSQL.
- Implementación de transacciones y manejo de errores específicos de PostgreSQL.

## Reconstrucción del Backend para Arquitectura Serverless

### Desafíos de la Arquitectura Serverless

La adaptación del backend de Express tradicional a una arquitectura serverless en Vercel presentó varios desafíos:

1. **Ciclo de vida de las funciones**: Las funciones serverless tienen un ciclo de vida efímero, lo que requiere un enfoque diferente para el mantenimiento de estado y conexiones.
2. **Limitaciones de tiempo de ejecución**: Las funciones tienen límites de tiempo de ejecución que no existían en el servidor Express tradicional.
3. **Manejo de conexiones a base de datos**: Necesidad de implementar pooling y conexiones efímeras debido a las características de las funciones serverless.
4. **Rutas y middleware**: La estructura de rutas y middleware de Express no se traslada directamente a funciones serverless.

### Implementación de Rutas de API con Next.js App Router

La reconstrucción del backend implicó:

1. **Migración de controladores**: Transformación de los controladores Express a funciones compatibles con la API de Next.js.
   - Cada endpoint de API se convirtió en un archivo `route.ts` dentro de la estructura de directorios de Next.js App Router.
   - Se implementaron las funciones HTTP correspondientes (GET, POST, PUT, DELETE) según el estándar de Next.js.

2. **Adaptación del manejo de parámetros**: En particular, se tuvo que abordar un desafío específico con los parámetros dinámicos en las rutas, que en Next.js 15 se manejan como promesas:

   ```typescript
   export async function GET(
     request: NextRequest,
     { params }: { params: Promise<{ id: string }> }
   ) {
     // Resolver params como promesa
     const resolvedParams = await params;
     const blogId = parseInt(resolvedParams.id, 10);
     // ...resto del código
   }
   ```

3. **Optimización de las conexiones a base de datos**: Implementación de un sistema de conexión eficiente que evita la sobrecarga de conexiones en entornos serverless:

   - Uso de un pool de conexiones configurable según la carga.
   - Implementación de lógica para reutilizar conexiones cuando sea posible.
   - Cierre adecuado de conexiones después de su uso para evitar fugas de recursos.

4. **Manejo de autenticación**: Adaptación del sistema de autenticación para funcionar en un entorno serverless, asegurando la seguridad en cada invocación de función.

5. **Implementación de manejo de errores robusto**: Desarrollo de un sistema uniforme para capturar, registrar y responder a errores en toda la aplicación:

   ```typescript
   try {
     // Lógica de la función
   } catch (error) {
     console.error("Error detallado:", error);
     return NextResponse.json(
       { 
         success: false,
         error: "Mensaje de error para el usuario", 
         details: (error as Error).message,
         stack: process.env.NODE_ENV !== 'production' ? (error as Error).stack : undefined
       },
       { status: 500 }
     );
   }
   ```

### Ventajas de la Nueva Arquitectura

Esta reconstrucción ha proporcionado varias ventajas:

1. **Mejor escalabilidad**: La aplicación ahora puede manejar picos de tráfico sin provisionamiento manual.
2. **Reducción de costos operativos**: Solo se paga por el tiempo de ejecución real.
3. **Despliegue simplificado**: El proceso de CI/CD está completamente integrado con GitHub.
4. **Mayor disponibilidad**: La aplicación se beneficia de la infraestructura global de Vercel.
5. **Mejor rendimiento**: Las funciones serverless se ejecutan cerca de los usuarios gracias a la red global de Vercel.

## Implementación de Detección de Entorno para Conexiones a WordPress

Un desafío importante en la migración fue gestionar las diferencias entre el entorno de desarrollo local y el entorno de producción en Vercel, especialmente para las conexiones a WordPress.

### Problema de las URLs Locales en Producción

Se identificó un problema crítico: cuando la aplicación intentaba conectarse a instancias de WordPress configuradas con URLs locales (por ejemplo, `http://localhost/auditivo_wordpress`) desde el entorno de producción en Vercel, estas conexiones fallaban con errores del tipo:

```
Error 500, no se puede acceder a https://proyecto-daw-4.vercel.app/api/wordpress/post/3 
Mensaje de test: {"success":false,"error":"Error al probar la conexión con WordPress",
"details":"fetch failed"}
```

Esto ocurre porque `localhost` en el servidor de Vercel se refiere al propio servidor, no a la máquina de desarrollo local.

### Solución Implementada

Se implementó una solución robusta para manejar este escenario:

1. **Detección de entorno**: Se añadió código para detectar automáticamente si la aplicación está ejecutándose en un entorno de producción:

   ```typescript
   const isProduction = process.env.NODE_ENV === 'production';
   ```

2. **Validación de URLs**: Se añadió lógica para identificar URLs de localhost en configuraciones de blog:

   ```typescript
   const isLocalhost = wpApiUrl.includes('localhost') || wpApiUrl.includes('127.0.0.1');
   ```

3. **Manejo inteligente de errores**: Si se detecta que la aplicación está en producción e intenta conectarse a una URL de localhost, se proporciona un mensaje de error claro y útil para el usuario:

   ```typescript
   if (isProduction && isLocalhost) {
     return NextResponse.json({
       success: false,
       error: "Error de configuración",
       details: "No se puede acceder a URLs de localhost en un entorno de producción. Por favor, actualice la URL del blog con una dirección accesible públicamente.",
       environment: process.env.NODE_ENV,
       url: wpApiUrl,
     }, { status: 400 });
   }
   ```

4. **Enriquecimiento del diagnóstico**: Se mejoró el endpoint de diagnóstico para proporcionar información adicional sobre la configuración del blog, incluyendo advertencias claras sobre el uso de URLs de localhost en producción:

   ```typescript
   const diagnostico = {
     // ...otros campos
     es_localhost: isLocalhost,
     advertencia_produccion: isProduction && isLocalhost ? 
       "Esta URL usa 'localhost', que no es accesible en entornos de producción. Por favor, use una URL pública." : 
       null,
     entorno: process.env.NODE_ENV || 'desarrollo',
   };
   ```

## Implementación de ngrok para Desarrollo y Pruebas

Para facilitar el desarrollo y las pruebas con WordPress locales desde el entorno de producción, se implementó el uso de ngrok como solución de túnel seguro.

### ¿Qué es ngrok y cómo se integra?

ngrok es una herramienta que permite exponer servicios locales a internet a través de túneles seguros. En el contexto de este proyecto:

1. **Exposición de WordPress local**: ngrok permite que un WordPress instalado localmente (por ejemplo, en XAMPP o WAMP) sea accesible desde internet con una URL temporal.

2. **Proceso de implementación**:
   - Instalación de ngrok en la máquina de desarrollo.
   - Ejecución del comando `ngrok http 80` para exponer el servidor web local.
   - Obtención de una URL pública temporal (por ejemplo, `https://1234abcd.ngrok.io`).
   - Configuración de la URL de la API de WordPress en la aplicación utilizando la URL de ngrok seguida de la ruta específica (por ejemplo, `https://1234abcd.ngrok.io/auditivo_wordpress`).

3. **Ventajas para el desarrollo**:
   - Permite probar la integración completa en el entorno de producción sin necesidad de desplegar un WordPress público.
   - Facilita la depuración de problemas específicos de la integración.
   - Proporciona un entorno de prueba realista sin costos adicionales de hosting.

### Documentación del Uso de ngrok

Se ha añadido documentación detallada para el equipo de desarrollo sobre cómo utilizar ngrok:

1. **Instalación**: `winget install Ngrok.Ngrok` en Windows o métodos equivalentes en otros sistemas operativos.

2. **Configuración**: Creación de una cuenta gratuita en ngrok.com y autenticación del cliente con `ngrok config add-authtoken <token>`.

3. **Uso básico**: Ejecución de `ngrok http 80` para exponer el servidor web local.

4. **Configuración en la aplicación**: Instrucciones para actualizar la URL de la API de WordPress en la base de datos con la URL de ngrok + la ruta específica de la instalación.

5. **Limitaciones**: Documentación de las limitaciones de la versión gratuita de ngrok, principalmente el hecho de que la URL pública cambia cada vez que se reinicia ngrok.

## Conclusiones sobre la Migración

La migración a Vercel y la adaptación a una arquitectura serverless ha representado un hito significativo en el desarrollo del proyecto, proporcionando:

1. **Mejora en la escalabilidad y rendimiento**: La aplicación ahora puede manejar cargas variables de manera eficiente.

2. **Reducción de la complejidad operativa**: La gestión de infraestructura se ha simplificado significativamente.

3. **Mejor experiencia de desarrollo**: El flujo de trabajo de desarrollo se ha optimizado con despliegues automáticos e integración continua.

4. **Mayor robustez**: El manejo mejorado de errores y la detección de configuraciones problemáticas (como URLs de localhost en producción) ha aumentado la fiabilidad del sistema.

5. **Flexibilidad para desarrollo y pruebas**: La integración de ngrok proporciona un puente eficaz entre el desarrollo local y el entorno de producción.

Esta migración no solo ha mejorado las características técnicas del proyecto, sino que también ha establecido una base sólida para el crecimiento futuro y la adición de nuevas funcionalidades.